#!/usr/bin/env lua
-- make.lua
-- Copyrighted (C) 2025 EntropyCoset on BSD 2-clause licence, also released as Public Domain

local lfs = require("lfs")
local posix = require("posix")

---------------------------------------------------------------------

function help()
	print [[
p2e-dev-node1 h    - this shows help and exits
p2e-dev-node1 d    - delete the run data
p2e-dev-node1 x    - this starts editing this script here
p2e-dev-node1 MODE CHAIN ROLE OPTIONS
p2e-dev-node1 normal bit node
p2e-dev-node1 normal ec1 wit01
p2e-dev-node1 gdb ec1 wit01

OPTIONS: -dry (dry run).
]]
end

---------------------------------------------------------------------

function begins_with(str, prefix)
	if (type(str) ~= "string") or (type(prefix) ~= "string") then error("Must call begin_with() with 2 strings.",2) end
	return str:sub(1, #prefix) == prefix
end


local function detect_os()
  local windows_slash = package.config:sub(1,1) == '\\' ;
  
  if jit and jit.os then
		print("Read jit.os [" .. jit.os .. "]")
    if jit.os == "Windows" then
      if not windows_slash then error("Can not detect OS, conflict between (win) jit.os(" .. jit.os .. ") and slash") end
      return "Windows"
    end
    if jit.os == "OSX" then
			if windows_slash then error("Can not detect OS, conflict between (OSX) jit.os(" .. jit.os .. ") and slash") end
      return "Darwin"
		else -- we assume the rest are unix-like
			if windows_slash then error("Can not detect OS, conflict between (misc) jit.os(" .. jit.os .. ") and slash") end
      return "Unixes"
		end
	else
		print("(Can not read OS name from JIT, will try other detection)")
  end

  if windows_slash then
    return "Windows"
  else
    local uname = io.popen("uname"):read("*l")
		print("Read uname [" .. uname .. "]")
    if uname == "Darwin" then
      return "Darwin"
    else
      return "Unixes"
    end
  end
end

local os_family = detect_os()
print ( "os_family: " .. os_family )

---------------------------------------------------------------------

-- TODO compare vs https://mojoauth.com/escaping/command-line-argument-escaping-in-lua/ and more
local function escape_arg_unix(arg)
  -- Replace every single quote ' with '\'' which is:
  -- close quote, escaped single quote, open quote
  return "'" .. tostring(arg):gsub("'", "'\\''") .. "'"
end

local function escape_args_unix(args)
  local escaped = {}
  for i, arg in ipairs(args) do
    escaped[i] = escape_arg_unix(arg)
  end
  return table.concat(escaped, " ")
end

---------------------------------------

local function escape_arg_windows(arg)
  -- Convert to string
  arg = tostring(arg)

  -- Double all double quotes inside argument
  arg = arg:gsub('"', '""')

  -- Wrap in double quotes if needed (spaces or special chars)
  if arg:match('[ \t"^&|<>%]') then
    arg = '"' .. arg .. '"'
  end

  return arg
end

local function escape_args_windows(args)
  local escaped = {}
  for i, arg in ipairs(args) do
    escaped[i] = escape_arg_windows(arg)
  end
  return table.concat(escaped, " ")
end

---------------------------------------

local function escape_arg(arg)
	if (os_family == "Unixes") or (os_family == "Darwin") then
		return escape_arg_unix(arg)
	elseif (os_family == "Windows") then
		return escape_arg_windows(arg)
	else
		error("do not know how to escape arguments on os family (" .. os_family .. ")")
	end
end
local function escape_args(args)
	if (os_family == "Unixes") or (os_family == "Darwin") then
		return escape_args_unix(args)
	elseif (os_family == "Windows") then
		return escape_args_windows(args)
	else
		error("do not know how to escape argsuments on os family (" .. os_family .. ")")
	end
end

---------------------------------------------------------------------

local	extract_keys_jsonfile -- (json_fn, target_name)


local json = require("dkjson")  -- requires dkjson (https://github.com/LuaDist/dkjson)

-- You can hardcode the name here or pass via argument
local target_name = "wit01"

-- Load JSON from file or stdin
local function read_file(filename)
    local file = io.open(filename, "r")
    if not file then
        error("Failed to open file: " .. filename)
    end
    local content = file:read("*a")
    file:close()
    return content
end

-- Extract keys for the given name
local function extract_keys_jsondata(data, name)
    for _, account in ipairs(data.initial_accounts) do
        if account.name == name then
            local public_key = account.owner_key_full.public_key
            local private_key = account.owner_key_full.wif_priv_key
            local address = account.owner_key
            return public_key, private_key, address
        end
    end
    return nil, nil, nil
end

function extract_keys_jsonfile(json_fn, target_name)
	if not json_fn then error("extract json keys from file - but no filename") end
	if not target_name then error("extract json keys from file - but no target_name") end
	print("Loading JSON with private genesis keys from (" .. json_fn .. ") for target (" .. target_name .. ")")
    local json_text = read_file(json_fn)
    local data, pos, err = json.decode(json_text, 1, nil)
    if err then
        error("Failed to decode JSON: " .. err)
    end

    local pub, priv, addr = extract_keys_jsondata(data, target_name)

    if pub and priv and addr then
			return { pub = pub, priv = priv, addr = addr }
    else
        print("Can not (fully) load privkeys and data for account (witness): " .. target_name)
    end
end

---------------------------------------------------------------------


local cfg_mode = arg[1] or "normal"
local cfg_chain = arg[2] or "default"
local cfg_role = arg[3] or "node"

print("Mode of this script: " .. cfg_mode .. " ; Blockchain/genesis: " .. cfg_chain .. " ; our role: " .. cfg_role)

-- Special edit mode
if cfg_mode == "x" then
    local script = debug.getinfo(1).source:sub(2) -- get current script path
    os.execute("vim " .. script)
    print("After editing myself - exit")
    os.exit()
end
if cfg_mode == "h" then
	help()
	os.exit()
end

print([[
=====================================================================
]])

-- Compile showargs if not present
local function file_exists(path)
    local f = io.open(path, "r")
    if f then f:close() return true else return false end
end

local function is_executable(path)
    return os.execute('[ -x "' .. path .. '" ]') == 0
end

if not is_executable("./showargs") then
    if file_exists("./showargs.cpp") then
        local res = os.execute("g++ showargs.cpp -o showargs")
        if res ~= 0 then print("Cannot compile showargs") end
    end
end

-- good_rand() - safely generate random int in range
local function good_rand(max)
    local max_limit = 4294967296 - 2
    if max >= max_limit then
        io.stderr:write("ERROR: max value (" .. max .. ") exceeds 32bit limit (" .. max_limit .. ")\n")
        os.exit(1)
    end
    local handle = io.popen("od -An -N4 -tu4 < /dev/urandom")
    local rnd = tonumber(handle:read("*a"):match("%d+"))
    handle:close()
    return rnd % (max + 1)
end

print("Cleanup of old run data (delete / remove)")
os.execute("rm -rf ./witness_node_data_dir/") -- No check, will continue on error
if cfg_mode == "d" then
	print("Removed - done, exiting")
	os.exit()
end

-- Generate random ports
local r1 = good_rand(970)
local port1 = r1 + 1025
local port2 = port1 + 1

print("port1=" .. port1 .. " port2=" .. port2)

local home = os.getenv("HOME")

-- Determine genesis file
local genesis_map = {
    default = { genesis = home .. "/chain-p2e/test-genesis-p2e1.json", private = nil },
    p2e1 = { genesis = home .. "/chain-p2e/test-genesis-p2e1.json", private = nil }, -- the private json is somewhere (todo?)
    ec1  = { genesis = home .. "/chain-p2e/test-genesis-ec1.json", private = home .. "/chain-p2e/SECRET/test-genesis-ec1/private.json" },
    bit2  = { genesis = home .. "/chain-p2e/bitshares1-mod.json", private = nil }, -- real bitshares main chain
    bit  = { genesis = home .. "/chain-p2e/bitshares1.json", private = nil }, -- real bitshares main chain
}
local genesis_fn = genesis_map[cfg_chain].genesis
local genesis_fn_private = genesis_map[cfg_chain].private

if not genesis_map[cfg_chain] then
    print("Unknown chain: " .. cfg_chain)
end

print("Genesis filename: " .. genesis_fn)

-- Load secret
local mykey = { pub = nil, priv = nil }
local mysettings = { witness_id = nil }

if cfg_role == "one" then -- the old way
	mykey.pub = "BTS5k46b9hXwYjLCZZy8usUGjtREeoQeEoLRUonJVkvp9GvVM3bx9"
	local privkey1_fullfn = home .. "/.devel/SECRET/pay2exchange/" .. mykey.pub .. ".secret"
	local privkey1_secret = ""
	if not file_exists(privkey1_fullfn) then
			print("Cannot read secret file (" .. privkey1_fullfn .. "). Aborting.")
			os.exit(1)
	else
			local file = io.open(privkey1_fullfn, "r")
			local line = file:read("*l")
			file:close()
			if not line:match("^[%w]+$") then
					print("The data read does not look correct. Aborting.")
					os.exit(1)
			else
					privkey1_secret = line
					print("Read secret key.")
					mykey.priv = privkey1_secret
					mysettings.witness_id = '1.6.1'
			end
	end
elseif begins_with(cfg_role, "wit") then
	wit=cfg_mode
	print("You are a witness (" .. wit .. ")")
	if not genesis_fn_private then
		error("You attempt to have role of a witness, but we do not have genesis-private. wrong chain? chain is: " .. cfg_chain)
	end
	mykey = extract_keys_jsonfile(genesis_fn_private, cfg_role)
elseif begins_with(cfg_role, "node") then
	print("You are just a node (not a witness - not loading wit privkey)")
else
	print("Unknown role (" .. cfg_role .. ")")
	os.exit(1)
end

-- Construct program arguments
local prog = "programs/witness_node/witness_node"
local args = {
    "--rpc-endpoint=0.0.0.0:" .. port1,
    "--p2p-endpoint=0.0.0.0:" .. port2,
    "--enable-stale-production",
    "--genesis-json=" .. genesis_fn
}
if mykey.pub or mykey.priv then
  if not (mykey.pub and mykey.priv) then
    error("If you set mykey then set all of it.")
  end
	local arg_add = string.format('--private-key=["%s", "%s"]', mykey.pub, mykey.priv)
	print("Creating arg to set private-key: " .. arg_add)
  table.insert(args, arg_add)
end

if mysettings.witness_id then
	table.insert('--witness-id="' .. mysettings.witness_id ..  '"')
end

-- Check if witness_node is executable
local function file_is_executable(path)
    return os.execute('[ -x "' .. path .. '" ]') == 0
end

if not file_is_executable(prog) then
    io.stderr:write("ERROR: Required program '" .. prog .. "' not found or not executable.\n")
    os.exit(1)
end


function show_args(args)
	print("Arguments for program")
	for _, arg in ipairs(args) do
			print("  " .. arg)
	end

	-- Showargs
	if is_executable("./showargs") then
			print("-------------------")
			print("Arguments for program, as printed by a dummy program:")

			local prog = "./showargs"   -- or your curses program
			local argv = { [0] = prog }
			for i = 1, #args do
				argv[i] = args[i]
			end

			local pid = posix.fork()
			if pid == 0 then
				-- Child inherits stdin/stdout/stderr, so TTY stays attached
				posix.execp(prog, argv)
				-- If exec fails:
				posix._exit(127)
			else
				-- Parent waits for interactive program to exit
				posix.wait(pid)
			end
			print("-------------------")
	end -- if binary showargs
end -- our show_args()

-- print each argument to verify
for i, v in ipairs(args) do
  print("ARG[" .. i .. "] = " .. v)
end

show_args(args)

print("---------------------------------------------------------------------")

local run_modes={}


for _, v in ipairs(arg) do
  if v == "-dry" then print("Dry run requested. See args above. Exiting.\n") os.exit(0) end
end

local run_modes = {}

run_modes.n = function()
    posix.spawn(prog, {prog, args=args})
end
run_modes.normal = run_modes.n

print("---------------------------------------------------------------------")
if run_modes[cfg_mode] then
    run_modes[cfg_mode]()
else
    print("Unknown mode: " .. cfg_mode)
end

print([[
---------------------------------------------------------------------
]])

print("Done.")
print("Was running with args:")
show_args(args)





